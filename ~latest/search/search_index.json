{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"nbautoexport","text":"<p>Making it easier to code review Jupyter notebooks, one script at a time.</p> <p><code>nbautoexport</code> automatically exports Jupyter notebooks to various file formats (.py, .html, and more) upon save while using Jupyter. One great use case is to automatically have script versions of your notebooks to facilitate code review commenting.</p>"},{"location":"#installation","title":"Installation","text":"<p>First, you will need to install <code>nbautoexport</code>. This should be installed in the same environment you are running Jupyter Notebook or Jupyter Lab from. <code>nbautoexport</code> is available either from PyPI via <code>pip</code> or from conda-forge via <code>conda</code>.</p> <pre><code>pip install nbautoexport\n</code></pre> <pre><code>conda install nbautoexport --channel conda-forge\n</code></pre> <p>Then, to register <code>nbautoexport</code> to run automatically while using Jupyter Notebook or Jupyter Lab, run:</p> <pre><code>nbautoexport install\n</code></pre> <p>If you already have a Jupyter server running, you will need to restart it for this to take effect.</p>"},{"location":"#simple-usage","title":"Simple usage","text":"<p>Let's say you have a project and keep your notebooks in a <code>notebooks/</code> subdirectory.</p> <p>To configure that directory for automatic exporting, run the following command:</p> <pre><code>nbautoexport configure notebooks\n</code></pre> <p>This will create a configuration file <code>notebooks/.nbautoexport</code>.</p> <p>If you've set up <code>nbautoexport</code> to work with Jupyter (using the <code>install</code> command as detailed in the previous section), then any time you save a notebook in Jupyter, a hook will run that checks whether there is a <code>.nbautoexport</code> configuration file in the same directory as the notebook. If so, it will use the settings specified in that file to export your notebook. By default, it will generate a script version of your notebook named after the notebook (with the <code>.py</code> extension) and saved in the directory <code>notebooks/script</code>.</p> <p>If everything is working, your notebooks directory should end up with files like the below example:</p> <pre><code>notebooks\n\u251c\u2500\u25000.1-ejm-data-exploration.ipynb\n\u251c\u2500\u25000.2-ejm-feature-creation.ipynb\n\u2514\u2500\u2500 script\n    \u2514\u2500\u2500 0.1-ejm-data-exploration.py\n    \u2514\u2500\u2500 0.2-ejm-feature-creation.py\n</code></pre>"},{"location":"#configuring-export-options","title":"Configuring export options","text":"<p>The default <code>.nbautoexport</code> configuration file looks like this:</p> <pre><code>{\n\"export_formats\": [\n\"script\"\n],\n\"organize_by\": \"extension\"\n}\n</code></pre> <p>Upon save, this will lead to notebooks being exported to scripts which saved to the <code>notebooks/script</code> directory.</p> <pre><code>notebooks\n\u251c\u2500\u25000.1-ejm-data-exploration.ipynb\n\u251c\u2500\u25000.2-ejm-feature-creation.ipynb\n\u2514\u2500\u2500 script\n    \u2514\u2500\u2500 0.1-ejm-data-exploration.py\n    \u2514\u2500\u2500 0.2-ejm-feature-creation.py\n</code></pre> <p>An alternative way to organize exported files is to create a directory for each notebook. This can be handy for matching both the notebook and subdirectory when tab-completing and then globbing with <code>*</code> after the part that completed.</p> <pre><code>nbautoexport configure notebooks --organize-by notebook\n</code></pre> <pre><code>notebooks\n\u251c\u2500\u2500 0.1-ejm-data-exploration\n\u2502   \u2514\u2500\u2500 0.1-ejm-data-exploration.py\n\u251c\u2500\u2500 0.2-ejm-feature-creation\n\u2502   \u2514\u2500\u2500 0.2-ejm-feature-creation.py\n\u251c\u2500\u25000.1-ejm-data-exploration.ipynb\n\u2514\u2500\u25000.2-ejm-feature-creation.ipynb\n</code></pre> <p>If you do not like the settings you selected, you can always change them by either 1) re-running the <code>nbautoexport</code> command with new arguments and the <code>--overwrite</code> flag, or 2) manually editing the <code>.nbautoexport</code> file.</p> <p>You can also specify as many export formats as you'd like. We support most of the export formats available from <code>nbconvert</code>, such as <code>html</code>, <code>md</code>, and <code>pdf</code>. To specify formats, use the <code>--export-format</code> for each format you want to include.</p>"},{"location":"#advanced-example","title":"Advanced example","text":"<pre><code>nbautoexport configure sprint_one_notebooks -f script -f html --organize-by extension\n</code></pre> <p>Upon save, this creates <code>.py</code> and <code>.html</code> versions of the Jupyter notebooks in <code>sprint_one_notebooks</code> folder and results in the following organization:</p> <pre><code>notebooks\n\u251c\u2500\u25000.1-ejm-data-exploration.ipynb\n\u251c\u2500\u25000.2-ejm-feature-creation.ipynb\n\u251c\u2500\u2500 script\n\u2502   \u2514\u2500\u2500 0.1-ejm-data-exploration.py\n\u2502   \u2514\u2500\u2500 0.1-ejm-features-creation.py\n\u2514\u2500\u2500 html\n    \u2514\u2500\u2500 0.1-ejm-data-exploration.html\n    \u2514\u2500\u2500 0.1-ejm-features-creation.html\n</code></pre>"},{"location":"#more-functionality","title":"More functionality","text":"<p>The <code>nbautoexport</code> CLI has two additional commands:</p> <ul> <li><code>export</code> is for ad hoc exporting of a notebook or directory of notebooks</li> <li><code>clean</code> (EXPERIMENTAL) will delete files in a directory that are not generated by the current <code>.nbautoexport</code> configuration</li> </ul> <p>Use the <code>--help</code> flag to see the documentation.</p>"},{"location":"#command-line-help","title":"Command-line help","text":"<pre><code>nbautoexport --help\n</code></pre> <pre><code>Usage: nbautoexport [OPTIONS] COMMAND [ARGS]...\n\n  Automatically export Jupyter notebooks to various file formats (.py,\n  .html, and more) upon save. One great use case is to automatically have\n  script versions of your notebooks to facilitate code review commenting.\n\n  To set up, first use the 'install' command to register nbautoexport with\n  Jupyter. If you already have a Jupyter server running, you will need to\n  restart it.\n\n  Next, you will need to use the 'configure' command to create a\n  .nbautoexport configuration file in the same directory as the notebooks\n  you want to have export automatically.\n\n  Once nbautoexport is installed with the first step, exporting will run\n  automatically when saving a notebook in Jupyter for any notebook where\n  there is a .nbautoexport configuration file in the same directory.\n\nOptions:\n  --version             Show nbautoexport version.\n  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or\n                        customize the installation.\n\n  --help                Show this message and exit.\n\nCommands:\n  clean      (EXPERIMENTAL) Remove subfolders/files not matching...\n  configure  Create a .nbautoexport configuration file in a directory.\n  export     Manually export notebook or directory of notebooks.\n  install    Register nbautoexport post-save hook with Jupyter.\n</code></pre> <p>This repository was initially created using Cookiecutter with <code>audreyr/cookiecutter-pypackage</code>.</p>"},{"location":"changelog/","title":"History","text":""},{"location":"changelog/#050-2022-02-16","title":"0.5.0 (2022-02-16)","text":"<ul> <li>Removes support for Python 3.6.</li> <li>Removes explicit dependency on <code>pywinpty</code> for Windows environments.</li> </ul>"},{"location":"changelog/#041-2022-02-15","title":"0.4.1 (2022-02-15)","text":"<p>This will be the last version of <code>nbautoexport</code> that will have been tested on and officially support Python 3.6.</p> <ul> <li>Adds dependency on <code>pywinpty</code> for Windows environments with a version ceiling on the last version that works with Python 3.6. (Issue #90, PR #92)</li> </ul>"},{"location":"changelog/#040-2021-10-29","title":"0.4.0 (2021-10-29)","text":"<ul> <li>Logging improvements. (Issue #74, PR #80)</li> <li>Adds additional log statements during post-save hook initialization and execution to facilitate debugging.</li> <li>Changes runtime errors in post-save hook to be caught gracefully instead of interrupting user with an alert dialog in the Jupyter UI.</li> <li>Adds logging integration with active Jupyter applications. Logs will use Jupyter formatting.</li> <li>Changes <code>--verbose</code>/<code>-v</code> flag to work as a counter. <code>-v</code> will set log level to INFO, and <code>-vv</code> will set log level to <code>DEBUG</code>.</li> </ul>"},{"location":"changelog/#031-2021-03-10","title":"0.3.1 (2021-03-10)","text":"<ul> <li>Remove extraneous dependency on <code>jupyter_contrib_nbextensions</code>. Add <code>traitlets</code>, <code>notebook</code>, <code>jupyter_core</code>, and <code>nbformat</code> as explicit dependencies; previously they were treated as transitive dependencies even though they are actually direct dependencies. (Issue #68)</li> </ul>"},{"location":"changelog/#030-2021-02-18","title":"0.3.0 (2021-02-18)","text":"<ul> <li>Explicitly set all input and output file encodings to UTF-8, which fixes a bug with HTML exports on Windows with <code>nbconvert</code> v6.0. This version removes the version ceiling on &lt;6.</li> <li>This is not expected to cause any backwards compatibility issues. However, in the very unlikely instance that your <code>jupyter_notebook_config.py</code> file or your <code>nbautoexport.json</code> config file is Windows-1252-encoded and contains non-ASCII characters, you will need to convert them to UTF-8. (Issue #57, PR #61)</li> </ul>"},{"location":"changelog/#021-2020-09-18","title":"0.2.1 (2020-09-18)","text":"<ul> <li><code>nbconvert</code> released version 6, which may break HTML exports on Windows. Pinning to <code>nbconvert&lt;6</code> until we can address Issue #57.</li> </ul>"},{"location":"changelog/#020-2020-09-04","title":"0.2.0 (2020-09-04)","text":"<ul> <li>Add option to specify glob-style patterns to exclude files from deletion when using <code>clean</code>. See documentation for more details. (Issue #46, PR #54)</li> </ul>"},{"location":"changelog/#011-2020-08-06","title":"0.1.1 (2020-08-06)","text":"<ul> <li>Fixes missing <code>requirements.txt</code> bug when installing from source distribution. (Issue #50, PR #52)</li> </ul>"},{"location":"changelog/#010-2020-08-05","title":"0.1.0 (2020-08-05)","text":"<ul> <li>First release on PyPI.</li> </ul>"},{"location":"cleaning/","title":"Cleaning (Experimental)","text":"<p>While using <code>nbautoexport</code>, you may sometimes end up with leftover files you no longer want. Some ways this can happen are if you rename notebooks, or if you change your export configuration. The <code>nbautoexport</code> CLI has an experimental <code>clean</code> command to delete extraneous files.</p> <p>WARNING: the <code>clean</code> command can delete files irreversibly. Please use with care.</p>"},{"location":"cleaning/#basic-usage","title":"Basic usage","text":"<p>Let's say you have a project and keep your notebooks in a <code>notebooks/</code> subdirectory. You can clean it with:</p> <pre><code>nbautoexport clean notebooks/\n</code></pre> <p>Note that in order to use <code>clean</code>, this directory must be configured with <code>nbautoexport</code>, i.e., you have a <code>notebooks/.nbautoexport</code> configuration file.</p> <p>If you have some files that would be cleaned, you would see something that looks like this:</p> <pre><code>Identified following files to clean up:\n  notebooks/html/0.1-ejm-data-exploration.html\n  notebooks/html/0.2-ejm-feature-creation.html\n  notebooks/script/Untitled.py\nAre you sure you want to delete these files? [y/N]: \u2588\n</code></pre> <p>At this point, you can enter <code>y</code> to continue with the deletion or <code>n</code> to cancel the deletion. Alternatively, you can run the <code>clean</code> command with the <code>--dry-run</code> flag which will automatically exit at this point without performing any file deletion.</p>"},{"location":"cleaning/#how-it-works","title":"How it works","text":"<p>Let's say you have the following files:</p> <pre><code>notebooks/\n\u251c\u2500\u2500 .nbautoexport\n\u251c\u2500\u2500 0.1-ejm-data-exploration.ipynb\n\u251c\u2500\u2500 0.2-ejm-feature-creation.ipynb\n\u251c\u2500\u2500 html\n\u2502   \u251c\u2500\u2500 0.1-ejm-data-exploration.html\n\u2502   \u2514\u2500\u2500 0.2-ejm-feature-creation.html\n\u2514\u2500\u2500 script\n    \u251c\u2500\u2500 0.1-ejm-data-exploration.py\n    \u251c\u2500\u2500 0.2-ejm-feature-creation.py\n    \u2514\u2500\u2500 Untitled.py\n</code></pre> <p>and you have the following <code>.nbautoexport</code> configuration:</p> <pre><code>{\n\"export_formats\": [\n\"script\"\n],\n\"organize_by\": \"extension\"\n}\n</code></pre> <p>We have some extra files that we want to clean up:</p> <ul> <li><code>html/</code> has some exports from when we earlier had <code>html</code> as an export format.</li> <li><code>script/Untitled.py</code> got saved when we had an <code>Untitled.ipynb</code> notebook before it was renamed.</li> </ul> <p><code>nbautoexport</code>, based on the configuration file and the notebooks it finds, identifies which files are expected exports or other expected files based on normal <code>nbautoexport</code> and Jupyter usage. All other files found are marked for clean up.</p> <pre><code>$ nbautoexport clean notebooks/\n\nIdentified following files to clean up:\n  notebooks/html/0.1-ejm-data-exploration.html\n  notebooks/html/0.2-ejm-feature-creation.html\n  notebooks/script/Untitled.py\nAre you sure you want to delete these files? [y/N]: y\nRemoving identified files...\nRemoving empty subdirectories...\n  notebooks/html\nCleaning complete.\n</code></pre> <p>After running <code>clean</code>, we end up with the following files:</p> <pre><code>notebooks/\n\u251c\u2500\u2500 .nbautoexport\n\u251c\u2500\u2500 0.1-ejm-data-exploration.ipynb\n\u251c\u2500\u2500 0.2-ejm-feature-creation.ipynb\n\u2514\u2500\u2500 script\n    \u251c\u2500\u2500 0.1-ejm-data-exploration.py\n    \u2514\u2500\u2500 0.2-ejm-feature-creation.py\n</code></pre>"},{"location":"cleaning/#excluding-files","title":"Excluding files","text":"<p>Sometimes you may have additional files in the notebooks directory of your project that are intentional. You can use glob-style patterns indicate files to exclude from deletion.</p> <p>Building on the previous example, let's say we have the following files:</p> <pre><code>notebooks/\n\u251c\u2500\u2500 .nbautoexport\n\u251c\u2500\u2500 0.1-ejm-data-exploration.ipynb\n\u251c\u2500\u2500 0.2-ejm-feature-creation.ipynb\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 html\n\u2502   \u251c\u2500\u2500 0.1-ejm-data-exploration.html\n\u2502   \u2514\u2500\u2500 0.2-ejm-feature-creation.html\n\u251c\u2500\u2500 images\n\u2502   \u2514\u2500\u2500 diagram.png\n\u2514\u2500\u2500 script\n    \u251c\u2500\u2500 0.1-ejm-data-exploration.py\n    \u251c\u2500\u2500 0.2-ejm-feature-creation.py\n    \u2514\u2500\u2500 Untitled.py\n</code></pre> <p>We have additional files that we want to keep:</p> <ul> <li><code>README.md</code></li> <li><code>images/diagram.png</code></li> </ul> <p>We can specify glob-style patterns to exclude from cleaning with the <code>--clean-exclude</code> flag in the <code>configure</code> command. Alternatively, we could also directly manually edit the <code>.nbautoexport</code> configuration file.</p> <pre><code>nbautoexport configure notebooks/ \\\n--overwrite \\\n--clean-exclude README.md \\\n--clean-exclude images/*\n</code></pre> <pre><code>{\n\"export_formats\": [\n\"script\"\n],\n\"organize_by\": \"extension\",\n\"clean\": {\n\"exclude\": [\n\"README.md\",\n\"images/*\"\n]\n}\n}\n</code></pre> <p>Then, running the <code>clean</code> command:</p> <pre><code>$ nbautoexport clean notebooks/\n\nExcluding files from cleaning using the following patterns:\n  README.md\n  images/*\nIdentified following files to clean up:\n  notebooks/html/0.1-ejm-data-exploration.html\n  notebooks/html/0.2-ejm-feature-creation.html\n  notebooks/script/Untitled.py\nAre you sure you want to delete these files? [y/N]: y\nRemoving identified files...\nRemoving empty subdirectories...\n  notebooks/html\nCleaning complete.\n</code></pre> <p>We can see that <code>README.md</code> and <code>images/diagram.png</code> are left alone.</p> <pre><code>notebooks/\n\u251c\u2500\u2500 .nbautoexport\n\u251c\u2500\u2500 0.1-ejm-data-exploration.ipynb\n\u251c\u2500\u2500 0.2-ejm-feature-creation.ipynb\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 images\n\u2502   \u2514\u2500\u2500 diagram.png\n\u2514\u2500\u2500 script\n    \u251c\u2500\u2500 0.1-ejm-data-exploration.py\n    \u2514\u2500\u2500 0.2-ejm-feature-creation.py\n</code></pre>"},{"location":"cleaning/#-exclude-flag","title":"<code>--exclude</code> flag","text":"<p>You can also provide patterns to exclude with the <code>--exclude</code> (<code>-e</code>) flag when calling <code>clean</code>.</p> <pre><code>nbautoexport clean notebooks/ \\\n--exclude README.md \\\n--exclude images/*\n</code></pre> <p>Any patterns specified this way will be used in addition to the patterns in the <code>.nbautoexport</code> configuration.</p>"},{"location":"cleaning/#experimental-status","title":"Experimental status","text":"<p>The <code>clean</code> command is experimental. The logic for identifying files to delete may be in need of improvement. If you have any feedback from using the <code>clean</code> command, please let us know by creating a GitHub issue.</p>"},{"location":"api-reference/nbautoexport-clean/","title":"<code>nbautoexport.clean</code>","text":""},{"location":"api-reference/nbautoexport-clean/#nbautoexport.clean.find_files_to_clean","title":"<code>find_files_to_clean(directory, config)</code>","text":"<p>Given path to a notebooks directory watched by nbautoexport, find all files that are not expected exports by current nbautoexport configuration and existing notebooks, or other expected Jupyter or nbautoexport files.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>Path</code> <p>notebooks directory to find files to clean up</p> required <p>Returns:</p> Type Description <code>List[Path]</code> <p>List[Path]: list of files to clean up</p> Source code in <code>nbautoexport/clean.py</code> <pre><code>def find_files_to_clean(directory: Path, config: NbAutoexportConfig) -&gt; List[Path]:\n\"\"\"Given path to a notebooks directory watched by nbautoexport, find all files that are not\n    expected exports by current nbautoexport configuration and existing notebooks, or other\n    expected Jupyter or nbautoexport files.\n\n    Args:\n        directory (Path): notebooks directory to find files to clean up\n\n    Returns:\n        List[Path]: list of files to clean up\n    \"\"\"\n    notebooks: List[JupyterNotebook] = find_notebooks(directory)\n    expected_exports: List[Path] = get_expected_exports(notebooks, config)\n    checkpoints = (f for f in directory.glob(\".ipynb_checkpoints/*\") if f.is_file())\n    sentinel_path = directory / SAVE_PROGRESS_INDICATOR_FILE\n\n    subfiles = (f for f in directory.glob(\"**/*\") if f.is_file())\n\n    to_clean = (\n        set(subfiles)\n        .difference(nb.path for nb in notebooks)\n        .difference(expected_exports)\n        .difference(globs(directory=directory, patterns=config.clean.exclude))\n        .difference(checkpoints)\n        .difference([sentinel_path])\n    )\n    return sorted(to_clean)\n</code></pre>"},{"location":"api-reference/nbautoexport-clean/#nbautoexport.clean.get_expected_exports","title":"<code>get_expected_exports(notebooks, config)</code>","text":"<p>Given an iterable of Jupyter notebooks, return list of paths of files that nbautoexport would be expected to export to given this configuration.</p> <p>Parameters:</p> Name Type Description Default <code>notebooks</code> <code>Iterable[JupyterNotebooks]</code> <p>iterable of notebooks</p> required <p>Returns:</p> Type Description <code>List[Path]</code> <p>List[Path]: list of expected nbautoexport output files, relative to notebook files</p> Source code in <code>nbautoexport/clean.py</code> <pre><code>def get_expected_exports(\n    notebooks: Iterable[JupyterNotebook], config: NbAutoexportConfig\n) -&gt; List[Path]:\n\"\"\"Given an iterable of Jupyter notebooks, return list of paths of files that nbautoexport\n    would be expected to export to given this configuration.\n\n    Args:\n        notebooks (Iterable[JupyterNotebooks]): iterable of notebooks\n\n    Returns:\n        List[Path]: list of expected nbautoexport output files, relative to notebook files\n    \"\"\"\n\n    export_paths: Set[Path] = set()\n    for notebook in notebooks:\n        for export_format in config.export_formats:\n            export_paths.update(\n                notebook_exports_generator(notebook, export_format, config.organize_by)\n            )\n    return sorted(export_paths)\n</code></pre>"},{"location":"api-reference/nbautoexport-clean/#nbautoexport.clean.get_extension","title":"<code>get_extension(notebook, export_format)</code>","text":"<p>Given a notebook and export format, return expected export file extension.</p> <p>Parameters:</p> Name Type Description Default <code>notebook</code> <code>JupyterNotebook</code> <p>notebook to determine extension for</p> required <code>export_format</code> <code>str</code> <p>export format name</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>file extension, e.g., '.py'</p> Source code in <code>nbautoexport/clean.py</code> <pre><code>def get_extension(notebook: JupyterNotebook, export_format: ExportFormat) -&gt; str:\n\"\"\"Given a notebook and export format, return expected export file extension.\n\n    Args:\n        notebook (JupyterNotebook): notebook to determine extension for\n        export_format (str): export format name\n\n    Returns:\n        str: file extension, e.g., '.py'\n    \"\"\"\n    # Script format needs notebook to determine appropriate language's extension\n    if ExportFormat(export_format) == ExportFormat.script:\n        return notebook.get_script_extension()\n\n    exporter = get_exporter(ExportFormat(export_format).value)\n\n    if ExportFormat(export_format) == ExportFormat.notebook:\n        return f\".nbconvert{exporter().file_extension}\"\n    return exporter().file_extension\n</code></pre>"},{"location":"api-reference/nbautoexport-clean/#nbautoexport.clean.globs","title":"<code>globs(directory, patterns)</code>","text":"<p>Generator that yields paths matching glob-style patterns relative to directory.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>Path</code> <p>a directory</p> required <code>patterns</code> <code>Iterable[str]</code> <p>glob-style patterns relative to directory</p> required <p>Yields:</p> Name Type Description <code>Path</code> <code>Iterable[Path]</code> <p>paths matching provided patterns relative to directory</p> Source code in <code>nbautoexport/clean.py</code> <pre><code>def globs(directory: Path, patterns: Iterable[str]) -&gt; Iterable[Path]:\n\"\"\"Generator that yields paths matching glob-style patterns relative to directory.\n\n    Args:\n        directory (Path): a directory\n        patterns (Iterable[str]): glob-style patterns relative to directory\n\n    Yields:\n        Path: paths matching provided patterns relative to directory\n    \"\"\"\n    for pattern in patterns:\n        yield from directory.glob(pattern)\n</code></pre>"},{"location":"api-reference/nbautoexport-clean/#nbautoexport.clean.notebook_exports_generator","title":"<code>notebook_exports_generator(notebook, export_format, organize_by)</code>","text":"<p>Generator that yields paths of expected exports for a notebook given an export_format and an organize_by setting.</p> <p>Parameters:</p> Name Type Description Default <code>notebook</code> <code>JupyterNotebook</code> <p>notebook to get export paths for</p> required <code>export_format</code> <code>ExportFormat</code> <p>export format</p> required <code>organize_by</code> <code>OrganizeBy</code> <p>type of subfolder approach</p> required <p>Yields:</p> Name Type Description <code>Path</code> <code>Iterable[Path]</code> <p>expected export paths given notebook and configuration options</p> Source code in <code>nbautoexport/clean.py</code> <pre><code>def notebook_exports_generator(\n    notebook: JupyterNotebook, export_format: ExportFormat, organize_by: OrganizeBy\n) -&gt; Iterable[Path]:\n\"\"\"Generator that yields paths of expected exports for a notebook given an export_format and\n    an organize_by setting.\n\n    Args:\n        notebook (JupyterNotebook): notebook to get export paths for\n        export_format (ExportFormat): export format\n        organize_by (OrganizeBy): type of subfolder approach\n\n    Yields:\n        Path: expected export paths given notebook and configuration options\n    \"\"\"\n    if organize_by == OrganizeBy.notebook:\n        subfolder = notebook.path.parent / notebook.name\n    elif organize_by == OrganizeBy.extension:\n        subfolder = notebook.path.parent / export_format.value\n    yield subfolder\n    yield subfolder / f\"{notebook.name}{get_extension(notebook, export_format)}\"\n    if export_format in FORMATS_WITH_IMAGE_DIR:\n        image_dir = subfolder / f\"{notebook.name}_files\"\n        if image_dir.exists():\n            yield image_dir\n            yield from image_dir.iterdir()\n</code></pre>"},{"location":"api-reference/nbautoexport-export/","title":"<code>nbautoexport.export</code>","text":""},{"location":"api-reference/nbautoexport-export/#nbautoexport.export.CopyToSubfolderPostProcessor","title":"<code>CopyToSubfolderPostProcessor</code>","text":"<p>         Bases: <code>PostProcessorBase</code></p> Source code in <code>nbautoexport/export.py</code> <pre><code>class CopyToSubfolderPostProcessor(PostProcessorBase):\n    def __init__(self, subfolder: str, export_format: ExportFormat):\n        self.subfolder = subfolder\n        self.export_format = export_format\n        super(CopyToSubfolderPostProcessor, self).__init__()\n\n    def postprocess(self, input: str):\n\"\"\"Save converted file to a separate directory, removing cell numbers.\"\"\"\n        if self.subfolder is None:\n            return\n\n        input: Path = Path(input)\n\n        new_dir = input.parent / self.subfolder\n        new_dir.mkdir(exist_ok=True)\n        new_path = new_dir / input.name\n\n        if self.export_format == ExportFormat.pdf:\n            # Can't read pdf file as unicode, skip rest of postprocessing and just copy\n            input.replace(new_path)\n            return\n\n        # Rewrite converted file to new path, removing cell numbers\n        with input.open(\"r\", encoding=\"utf-8\") as f:\n            text = f.read()\n        with new_path.open(\"w\", encoding=\"utf-8\") as f:\n            f.write(re.sub(r\"\\n#\\sIn\\[(([0-9]+)|(\\s))\\]:\\n{2}\", \"\", text))\n\n        # For some formats, we also need to move the assets directory, for stuff like images\n        if self.export_format in FORMATS_WITH_IMAGE_DIR:\n            assets_dir = input.parent / f\"{input.stem}_files\"\n            if assets_dir.exists() and assets_dir.is_dir():\n                new_assets_dir = new_dir / f\"{input.stem}_files\"\n                new_assets_dir.mkdir(exist_ok=True)\n                for asset in assets_dir.iterdir():\n                    asset.replace(new_assets_dir / asset.name)\n                assets_dir.rmdir()\n\n        input.unlink()\n</code></pre>"},{"location":"api-reference/nbautoexport-export/#nbautoexport.export.CopyToSubfolderPostProcessor.postprocess","title":"<code>postprocess(input)</code>","text":"<p>Save converted file to a separate directory, removing cell numbers.</p> Source code in <code>nbautoexport/export.py</code> <pre><code>def postprocess(self, input: str):\n\"\"\"Save converted file to a separate directory, removing cell numbers.\"\"\"\n    if self.subfolder is None:\n        return\n\n    input: Path = Path(input)\n\n    new_dir = input.parent / self.subfolder\n    new_dir.mkdir(exist_ok=True)\n    new_path = new_dir / input.name\n\n    if self.export_format == ExportFormat.pdf:\n        # Can't read pdf file as unicode, skip rest of postprocessing and just copy\n        input.replace(new_path)\n        return\n\n    # Rewrite converted file to new path, removing cell numbers\n    with input.open(\"r\", encoding=\"utf-8\") as f:\n        text = f.read()\n    with new_path.open(\"w\", encoding=\"utf-8\") as f:\n        f.write(re.sub(r\"\\n#\\sIn\\[(([0-9]+)|(\\s))\\]:\\n{2}\", \"\", text))\n\n    # For some formats, we also need to move the assets directory, for stuff like images\n    if self.export_format in FORMATS_WITH_IMAGE_DIR:\n        assets_dir = input.parent / f\"{input.stem}_files\"\n        if assets_dir.exists() and assets_dir.is_dir():\n            new_assets_dir = new_dir / f\"{input.stem}_files\"\n            new_assets_dir.mkdir(exist_ok=True)\n            for asset in assets_dir.iterdir():\n                asset.replace(new_assets_dir / asset.name)\n            assets_dir.rmdir()\n\n    input.unlink()\n</code></pre>"},{"location":"api-reference/nbautoexport-export/#nbautoexport.export.export_notebook","title":"<code>export_notebook(notebook_path, config)</code>","text":"<p>Export a given notebook file given configuration.</p> <p>Parameters:</p> Name Type Description Default <code>notebook_path</code> <code>Path</code> <p>path to notebook to export with nbconvert</p> required <code>config</code> <code>NbAutoexportConfig</code> <p>configuration</p> required Source code in <code>nbautoexport/export.py</code> <pre><code>def export_notebook(notebook_path: Path, config: NbAutoexportConfig):\n\"\"\"Export a given notebook file given configuration.\n\n    Args:\n        notebook_path (Path): path to notebook to export with nbconvert\n        config (NbAutoexportConfig): configuration\n    \"\"\"\n    logger.info(f\"nbautoexport | Exporting {notebook_path} ...\")\n    logger.debug(f\"nbautoexport | Using export configuration:\\n{config.json(indent=2)}\")\n    with cleared_argv():\n        converter = NbConvertApp()\n        converter.log.handlers = logger.handlers\n        converter.log.setLevel(logger.level)\n\n        for export_format in config.export_formats:\n            if config.organize_by == \"notebook\":\n                subfolder = notebook_path.stem\n            elif config.organize_by == \"extension\":\n                subfolder = export_format.value\n\n            converter.postprocessor = CopyToSubfolderPostProcessor(\n                subfolder=subfolder, export_format=export_format\n            )\n            converter.export_format = export_format.value\n            converter.initialize()\n            converter.notebooks = [str(notebook_path)]\n            converter.convert_notebooks()\n</code></pre>"},{"location":"api-reference/nbautoexport-export/#nbautoexport.export.post_save","title":"<code>post_save(model, os_path, contents_manager)</code>","text":"<p>Post-save hook for converting notebooks to other formats using Jupyter nbconvert and saving in a subfolder.</p> <p>The following arguments are standard for Jupyter post-save hooks. See Jupyter Documentation.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>dict</code> <p>the model representing the file. See Jupyter documentation.</p> required <code>os_path</code> <code>str</code> <p>the filesystem path to the file just written</p> required <code>contents_manager</code> <code>FileContentsManager</code> <p>FileContentsManager instance that hook is bound to</p> required Source code in <code>nbautoexport/export.py</code> <pre><code>def post_save(model: dict, os_path: str, contents_manager: FileContentsManager):\n\"\"\"Post-save hook for converting notebooks to other formats using Jupyter nbconvert and saving\n    in a subfolder.\n\n    The following arguments are standard for Jupyter post-save hooks. See [Jupyter Documentation](\n    https://jupyter-notebook.readthedocs.io/en/stable/extending/savehooks.html).\n\n    Args:\n        model (dict): the model representing the file. See [Jupyter documentation](\n            https://jupyter-notebook.readthedocs.io/en/stable/extending/contents.html#data-model).\n        os_path (str): the filesystem path to the file just written\n        contents_manager (FileContentsManager): FileContentsManager instance that hook is bound to\n    \"\"\"\n    logger.debug(\"nbautoexport | Executing nbautoexport.export.post_save ...\")\n    try:\n        # only do this for notebooks\n        if model[\"type\"] != \"notebook\":\n            logger.debug(f\"nbautoexport | {os_path} is not a notebook. Nothing to do.\")\n            return\n\n        # only do this if we've added the special indicator file to the working directory\n        notebook_path = Path(os_path)\n        cwd = notebook_path.parent\n        save_progress_indicator = cwd / SAVE_PROGRESS_INDICATOR_FILE\n        should_convert = save_progress_indicator.exists()\n\n        if should_convert:\n            logger.info(f\"nbautoexport | {save_progress_indicator} found. Exporting notebook ...\")\n            config = NbAutoexportConfig.parse_file(\n                path=save_progress_indicator, content_type=\"application/json\", encoding=\"utf-8\"\n            )\n            export_notebook(notebook_path, config=config)\n\n        else:\n            logger.debug(f\"nbautoexport | {save_progress_indicator} not found. Nothing to do.\")\n        logger.debug(\"nbautoexport | post_save successful.\")\n    except Exception as e:\n        logger.error(f\"nbautoexport | post_save failed due to {type(e).__name__}: {e}\")\n</code></pre>"},{"location":"api-reference/nbautoexport-jupyter_config/","title":"<code>nbautoexport.jupyter_config</code>","text":""},{"location":"api-reference/nbautoexport-jupyter_config/#nbautoexport.jupyter_config.install_post_save_hook","title":"<code>install_post_save_hook(config_path=None)</code>","text":"<p>Splices the post save hook into the global Jupyter configuration file</p> Source code in <code>nbautoexport/jupyter_config.py</code> <pre><code>def install_post_save_hook(config_path: Optional[Path] = None):\n\"\"\"Splices the post save hook into the global Jupyter configuration file\"\"\"\n    if config_path is None:\n        config_dir = jupyter_config_dir()\n        config_path = Path(config_dir) / \"jupyter_notebook_config.py\"\n\n    config_path = config_path.expanduser().resolve()\n\n    if not config_path.exists():\n        logger.debug(f\"No existing Jupyter configuration detected at {config_path}. Creating...\")\n        config_path.parent.mkdir(exist_ok=True, parents=True)\n        with config_path.open(\"w\", encoding=\"utf-8\") as fp:\n            fp.write(post_save_hook_initialize_block)\n        logger.info(\"nbautoexport post-save hook installed.\")\n        return\n\n    # If config exists, check for existing nbautoexport initialize block and install as appropriate\n    logger.debug(f\"Detected existing Jupyter configuration at {config_path}\")\n\n    with config_path.open(\"r\", encoding=\"utf-8\") as fp:\n        config = fp.read()\n\n    if block_regex.search(config):\n        logger.info(\"Detected existing nbautoexport post-save hook.\")\n\n        version_match = version_regex.search(config)\n        if version_match:\n            existing_version = version_match.group()\n            logger.debug(f\"Existing post-save hook is version {existing_version}\")\n        else:\n            existing_version = \"\"\n            logger.debug(\"Existing post-save hook predates versioning.\")\n\n        if existing_version == \"\" or parse_version(existing_version) &lt; parse_version(__version__):\n            logger.info(f\"Updating nbautoexport post-save hook with version {__version__}...\")\n            with config_path.open(\"w\", encoding=\"utf-8\") as fp:\n                # Open as w replaces existing file. We're replacing entire config.\n                escaped_init = post_save_hook_initialize_block.replace(\n                    \"\\\\\", r\"\\\\\"\n                )  # escape metachars\n                fp.write(block_regex.sub(escaped_init, config))\n        else:\n            logger.info(\"No changes made.\")\n            return\n    else:\n        logger.info(\"Installing post-save hook.\")\n        with config_path.open(\"a\") as fp:\n            # Open as a just appends. We append block at the end of existing file.\n            fp.write(\"\\n\" + post_save_hook_initialize_block)\n\n    logger.info(\"nbautoexport post-save hook installed.\")\n</code></pre>"},{"location":"api-reference/nbautoexport-sentinel/","title":"<code>nbautoexport.sentinel</code>","text":""},{"location":"api-reference/nbautoexport-sentinel/#nbautoexport.sentinel.install_sentinel","title":"<code>install_sentinel(directory, config, overwrite)</code>","text":"<p>Writes the configuration file to a specified directory.</p> Source code in <code>nbautoexport/sentinel.py</code> <pre><code>def install_sentinel(directory: Path, config: NbAutoexportConfig, overwrite: bool):\n\"\"\"Writes the configuration file to a specified directory.\"\"\"\n    sentinel_path = directory / SAVE_PROGRESS_INDICATOR_FILE\n\n    if sentinel_path.exists() and (not overwrite):\n        raise FileExistsError(\n            f\"\"\"Detected existing autoexport configuration at {sentinel_path}. \"\"\"\n\"\"\"If you wish to overwrite, use the --overwrite flag.\"\"\"\n        )\n    else:\n        logger.info(f\"Creating configuration file at {sentinel_path}\")\n        logger.info(f\"\\n{config.json(indent=2)}\")\n        with sentinel_path.open(\"w\", encoding=\"utf-8\") as fp:\n            fp.write(config.json(indent=2))\n</code></pre>"},{"location":"api-reference/nbautoexport-utils/","title":"<code>nbautoexport.utils</code>","text":""},{"location":"api-reference/nbautoexport-utils/#nbautoexport.utils.cleared_argv","title":"<code>cleared_argv()</code>","text":"<p>Context manager that temporarily clears sys.argv. Useful for wrapping nbconvert so unexpected arguments from outer program (e.g., nbautoexport) aren't passed to nbconvert.</p> Source code in <code>nbautoexport/utils.py</code> <pre><code>@contextmanager\ndef cleared_argv():\n\"\"\"Context manager that temporarily clears sys.argv. Useful for wrapping nbconvert so\n    unexpected arguments from outer program (e.g., nbautoexport) aren't passed to nbconvert.\n    \"\"\"\n    prev_argv = [arg for arg in sys.argv]\n    sys.argv = [sys.argv[0]]\n    try:\n        yield\n    finally:\n        sys.argv = prev_argv\n</code></pre>"},{"location":"api-reference/nbautoexport-utils/#nbautoexport.utils.find_notebooks","title":"<code>find_notebooks(directory)</code>","text":"<p>Finds Jupyter notebooks in a directory. Not recursive.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>Path</code> <p>directory to search for notebook files</p> required <p>Returns:</p> Type Description <code>List[JupyterNotebook]</code> <p>List[JupyterNotebook]: notebooks found</p> Source code in <code>nbautoexport/utils.py</code> <pre><code>def find_notebooks(directory: Path) -&gt; List[JupyterNotebook]:\n\"\"\"Finds Jupyter notebooks in a directory. Not recursive.\n\n    Args:\n        directory (Path): directory to search for notebook files\n\n    Returns:\n        List[JupyterNotebook]: notebooks found\n    \"\"\"\n    notebooks = []\n    for subfile in directory.iterdir():\n        if subfile.is_file() and subfile.name:\n            try:\n                notebook = nbformat.read(str(subfile), as_version=nbformat.NO_CONVERT)\n                nbformat.validate(notebook)\n                notebooks.append(JupyterNotebook(path=subfile, metadata=notebook.metadata))\n            except Exception as e:\n                if subfile.suffix.lower() == \".ipynb\":\n                    warn(\n                        f\"Error reading {subfile.resolve()} as Jupyter Notebook: \"\n                        + f\"[{type(e).__name__}] {e}\"\n                    )\n    return notebooks\n</code></pre>"},{"location":"api-reference/nbautoexport-utils/#nbautoexport.utils.working_directory","title":"<code>working_directory(directory)</code>","text":"<p>Changes working directory and returns to previous on exit.</p> Source code in <code>nbautoexport/utils.py</code> <pre><code>@contextmanager\ndef working_directory(directory: Path):\n\"\"\"Changes working directory and returns to previous on exit.\"\"\"\n    prev_cwd = Path.cwd()\n    os.chdir(directory)\n    try:\n        yield\n    finally:\n        os.chdir(prev_cwd)\n</code></pre>"},{"location":"command-reference/clean/","title":"clean Command","text":"<pre><code>nbautoexport clean --help\n</code></pre> <pre><code>Usage: nbautoexport clean [OPTIONS] DIRECTORY\n\n  (EXPERIMENTAL) Remove subfolders/files not matching .nbautoexport\n  configuration and existing notebooks.\n\n  Known limitations: - Not able to correctly handle additional intended files,\n  such as image assets or   non-notebook-related files.\n\nArguments:\n  DIRECTORY  Directory to clean. Must have a .nbautoexport config file.\n             [required]\n\nOptions:\n  -e, --exclude TEXT  Glob-style patterns that designate files to exclude from\n                      deletion. Combined with any patterns specified in\n                      .nbautoexport config file.\n  -y, --yes           Assume 'yes' answer to confirmation prompt to delete\n                      files.\n  --dry-run           Show files that would be removed, without actually\n                      removing.\n  -v, --verbose       Use multiple times to set verbosity/log level. [-v =\n                      INFO, -vv = DEBUG]\n  --help              Show this message and exit.\n</code></pre>"},{"location":"command-reference/configure/","title":"configure Command","text":"<pre><code>nbautoexport configure --help\n</code></pre> <pre><code>Usage: nbautoexport configure [OPTIONS] DIRECTORY\n\n  Create a .nbautoexport configuration file in a directory. If nbautoexport\n  has been installed with the 'install' command, then Jupyter will\n  automatically export any notebooks on save that are in the same directory as\n  the .nbautoexport file.\n\n  An .nbautoexport configuration file only applies to that directory,\n  nonrecursively. You must independently configure other directories\n  containing notebooks.\n\nArguments:\n  DIRECTORY  Path to directory of notebook files to configure with\n             nbautoexport.  [required]\n\nOptions:\n  -f, --export-format [asciidoc|html|latex|markdown|notebook|pdf|rst|script|slides]\n                                  File format(s) to save for each notebook.\n                                  Multiple formats should be provided using\n                                  multiple flags, e.g., '-f script -f html -f\n                                  markdown'.  [default: ExportFormat.script]\n  -b, --organize-by [notebook|extension]\n                                  Whether to save exported file(s) in a\n                                  subfolder per notebook or per export format.\n                                  [default: OrganizeBy.extension]\n  -e, --clean-exclude TEXT        Glob-style patterns that designate files to\n                                  exclude from deletion when running clean\n                                  command.\n  -o, --overwrite                 Overwrite existing configuration, if one is\n                                  detected.\n  -v, --verbose                   Use multiple times to set verbosity/log\n                                  level. [-v = INFO, -vv = DEBUG]\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"command-reference/export/","title":"export Command","text":"<pre><code>nbautoexport export --help\n</code></pre> <pre><code>Usage: nbautoexport export [OPTIONS] INPUT\n\n  Manually export notebook or directory of notebooks.\n\n  An .nbautoexport configuration file in same directory as notebook(s) will be\n  used if it exists. Configuration options specified by command-line options\n  will override configuration file. If no existing configuration option exists\n  and no values are provided, default values will be used.\n\n  The export command will not do cleaning, regardless of the 'clean' setting\n  in an .nbautoexport configuration file.\n\nArguments:\n  INPUT  Path to notebook file or directory of notebook files to export.\n         [required]\n\nOptions:\n  -f, --export-format [asciidoc|html|latex|markdown|notebook|pdf|rst|script|slides]\n                                  File format(s) to save for each notebook.\n                                  Multiple formats should be provided using\n                                  multiple flags, e.g., '-f script -f html -f\n                                  markdown'. Provided values will override\n                                  existing .nbautoexport config files. If\n                                  neither provided, defaults to\n                                  [&lt;ExportFormat.script: 'script'&gt;].\n  -b, --organize-by [notebook|extension]\n                                  Whether to save exported file(s) in a\n                                  subfolder per notebook or per export format.\n                                  Provided values will override existing\n                                  .nbautoexport config files. If neither\n                                  provided, defaults to 'extension'.\n  -v, --verbose                   Use multiple times to set verbosity/log\n                                  level. [-v = INFO, -vv = DEBUG]\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"command-reference/install/","title":"install Command","text":"<pre><code>nbautoexport install --help\n</code></pre> <pre><code>Usage: nbautoexport install [OPTIONS]\n\n  Register nbautoexport post-save hook with Jupyter. Note that if you already\n  have a Jupyter server running, you will need to restart in order for it to\n  take effect. This is a one-time installation.\n\n  This works by adding an initialization block in your Jupyter config file\n  that will register nbautoexport's post-save function. If an nbautoexport\n  initialization block already exists and is from an older version of\n  nbautoexport, this command will replace it with an updated version.\n\nOptions:\n  --jupyter-config FILE  Path to config file. If not specified (default), will\n                         determine appropriate path used by Jupyter. You\n                         should only specify this option if you use a\n                         nonstandard config file path that you explicitly pass\n                         to Jupyter with the --config option at startup.\n  -v, --verbose          Use multiple times to set verbosity/log level. [-v =\n                         INFO, -vv = DEBUG]\n  --help                 Show this message and exit.\n</code></pre>"}]}